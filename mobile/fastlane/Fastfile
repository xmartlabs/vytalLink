opt_out_usage
fastlane_require 'dotenv'

def compilation_envs
  if File.file?("#{root_path}/.env")
    Dotenv.parse("#{root_path}/.env")
      .map { |key, value| "--dart-define=#{key}=#{value}" }
      .join(' ')
  else
    ''
  end
end

def root_path
  Dir.pwd.sub(/.*\Kfastlane/, '').sub(/.*\Kandroid/, '').sub(/.*\Kios/, '').sub(/.*\K\/\//, '')
end

private_lane :sh_on_root do |options|
  command = options[:command]
  subdirectory = options[:subdirectory] || ''
  full_path = File.join(root_path, subdirectory)

  sh("cd #{full_path} && #{command}")
end

lane :generate_docs do 
  sh("bundle exec fastlane actions docs")
  sh("cd ../android && bundle exec fastlane actions docs")
  sh("cd ../ios && bundle exec fastlane actions docs")
end

private_lane :flutter_command do |options|
  command = options[:command]
  subdirectory = options[:subdirectory]
  sh_on_root(subdirectory: subdirectory, command: "fvm flutter #{command}")
end

private_lane :dart_command do |options|
  command = options[:command]
  sh_on_root(command: "fvm dart #{command}")
end

desc "**Clean project**"
private_lane :clean do
  flutter_command(command: "clean")
end

desc "**Fetch flutter dependencies**"
lane :fetch_dependencies do
  flutter_command(command: "pub get --suppress-analytics")
  # Template does not depends on design_system_galerry
  flutter_command(command: "pub get --suppress-analytics", subdirectory: "design_system/design_system_gallery")
end

desc "**Generate flutter generated code**"
lane :build_autogenerated_code do
  flutter_command(command: "pub run build_runner build --delete-conflicting-outputs")
end

desc "**Lint: Check code format**"
lane :lint_format do
  sh_on_root(command: "find lib -name '*.dart' ! -path 'lib/l10n/*' -print0 | xargs -0 fvm dart format -o none --set-exit-if-changed")
end

desc "**Lint: Check code format**"
lane :lint_check_language_sorting do
  current_content = sh_on_root(command: "cat lib/l10n/intl_en.arb")
  sh_on_root(command: "arb_utils sort lib/l10n/intl_en.arb")
  new_content = sh_on_root(command: "cat lib/l10n/intl_en.arb")
  unless current_content == new_content
    UI.user_error!("Language file is not sorted")
  end
end

desc "**Lint: Analyze code**"
lane :lint_analyze do
  flutter_command(command: "analyze lib")
  flutter_command(command: "analyze design_system/design_system_gallery")
  flutter_command(command: "analyze design_system")
end

desc "**Lint: Code metrics**"
lane :lint_code_metrics do
  result = flutter_command(command: "pub run dart_code_linter:metrics analyze lib  --fatal-style --fatal-performance --fatal-warnings")
  UI.message(result)
  unless result.include? "✔ no issues found!"
    UI.user_error!("Code metrics error happened")
  end

  flutter_command(command: "pub run dart_code_linter:metrics check-unused-code lib --fatal-unused")
end

desc "**Run linters**"
lane :lints do
  lint_format
  lint_check_language_sorting
  lint_analyze
  lint_code_metrics
end

desc "**Check generated code is fine**"
lane :ensure_no_change_in_generated_code do
  build_autogenerated_code
  ensure_git_status_clean(show_diff: true)
end

desc "**Run tests**"
lane :tests do |options|
  flutter_command(command: "test --no-pub --coverage --suppress-analytics")
end

desc "**Clean up project**"
lane :clean_up do
  clean
  fetch_dependencies
  build_autogenerated_code
end

lane :build_flutter do |options|
  build_type = options[:build_type] || ''
  if !build_type.empty?
    build_type = "--#{build_type}"
  end

  sign_disabled = options[:sign_disabled] || false
  sign_param = sign_disabled ? '--no-codesign' : ''

  build_platform = options[:build_platform]

  config_only = options[:config_only] || false
  config_param = config_only ? '--config-only' : ''
  
  flavor = options[:env] || ''
  
  version_name = calculate_version_name(
    include_git_version_suffix: options[:include_git_version_suffix] || false
  )

  export_method = options[:export_method] || ''
  if !export_method.empty?
    export_method = "--export-method #{export_method}"
  end

  flutter_command(command: "build #{build_platform} #{build_type} --suppress-analytics #{sign_param} #{config_param} --flavor #{flavor} --dart-define=ENV=#{flavor} --build-name #{version_name} #{export_method} #{compilation_envs}")
end

private_lane :calculate_version_name do |options|
  include_git_version_suffix = options[:include_git_version_suffix] || false
  version_suffix = include_git_version_suffix ? "-#{last_git_commit[:abbreviated_commit_hash]}" : ''
  version_name = flutter_version()["version_name"] + version_suffix
end

private_lane :generate_snapshot_changelog do
  changelog_from_git_commits(
    between: ["HEAD^", "HEAD"],
    pretty: "%s%n%nAuthor: %an <%ae>",
    date_format: "short",
  )
  header = Actions.lane_context[SharedValues::FL_CHANGELOG]
  changelog_from_git_commits(
    between: ["HEAD~10", "HEAD^"],
    pretty: "• %s",
    date_format: "short",
  )
  body = Actions.lane_context[SharedValues::FL_CHANGELOG]
    .split("\n")[0..10]
    .join("\n")
  ENV["CHANGELOG"] = "#{header}\n\nLast changes:\n#{body}"
  ENV["CHANGELOG"]
end

desc "**Get next Production Build Number**"
private_lane :get_next_production_build_number do
  version = ['prod', 'beta', 'alpha', 'internal'].map { |track|
    google_play_track_version_codes(
      track: track,
      json_key: ENV['GOOGLE_PLAY_SERVICE_ACCOUNT_CREDENTIALS_FILE'],
      json_key_data: ENV['GOOGLE_PLAY_SERVICE_ACCOUNT_CREDENTIALS_CONTENT']
    )
  }.flatten.map(&:to_i).max + 1
  version
end

desc "**Get next Staging Build Number**"
private_lane :get_next_staging_build_number do
  latest_release = firebase_app_distribution_get_latest_release(
    app: ENV['FIREBASE_APP_ID'],
    service_credentials_file: ENV['SERVICE_ACCOUNT']
  )
  version = latest_release[:buildVersion].to_i + 1
  version
end

desc "**Get next Build Number**"
lane :get_next_build_number do
  next_staging_build_number = get_next_staging_build_number
  next_production_build_number = get_next_production_build_number

  version = [next_staging_build_number, next_production_build_number].max
  UI.message "Next Build Number: #{version}"
  version
end
